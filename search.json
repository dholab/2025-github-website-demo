[
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "Setting up this project",
    "section": "",
    "text": "First, we make sure Quarto is installed, and then use it to create a project in the current working directory with quarto create project. This command is interactive and will guide you through creating the kind of project you want. In this case, the key point is that we want a website project to be created in the current working directory.\nThis will create a few files for use: the _quarto.yml file for whole-project configuration, the index.qmd file that will serve as the homepage and entrypoint for the website, and an about.qmd that will serve as an “About” page in a separate “tab” on the website. We also get a styles.css file, which allows us to do some aesthetic tweaks to what would otherwise be raw, boring HTML. The said, we don’t have to touch it in this case, as the Quarto renderer comes with a number of CSS themes built-in.\n\n\n\n\n\n\nHTML?\n\n\n\n\n\nThe power of Quarto is that it allows you to write simple Markdown and then render it into very long list of other formats, e.g., PowerPoint, PDF, etc. Because we’re using it to make a website, Quarto will be rendering our markdown into HTML, which can then be viewed in the browser.\n\n\n\nBefore we proceed, let’s tweak our Quarto configuration a bit. We’ll do these tweaks at two levels: the whole-project level in _quarto.yml, and in what’s referred to as the frontmatter in each .qmd file.\n\n\nFirst, open the _quarto.yml in your favorite editor (VSCode, Positron, and RStudio have the best support for Quarto, though you can use any editor you can set to recognize .qmd files as Markdown). Start by modifying the top block with an additional setting: output-dir: docs.\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: docs\n\nNote that the YAML language is very sensitive about indentation, similar to Python. Make sure your editor has good auto-indentation support when modifying these files.\nNext, we’ll modify the website block, which controls navigation and other website behaviors. In this case, I’m going to add a page by putting this qmd file in the list:\n\n\n_quarto.yml\n\nwebsite:\n  title: \"Creating Github-hosted Dashboards\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - about.qmd\n      - setup.qmd\n\nWe won’t touch the format section, but just note that that’s where we specify the theme we want applied to our HTML. These adjustments could be switching to a different built-in theme, or making out own tweaks manually in styles.css.\nFinally, we’re going to add a section at the bottom that tells Quarto not to rerun code unless it has been updated:\n\n\n_quarto.yml\n\nexecute:\n  freeze: auto\n\nAs the look and feel of our project comes together, we can expect to return to the _quarto.yml, but for now, that’s all we’ll need. There are a huge number of controls we can tweak, so I recommend keeping the Quarto docs handy.\n\n\n\nEach .qmd has its own YAML-based configuration, which you’ll see in index.qmd. To demo some of the controls we can use, I modified my index.qmd frontmatter to the following:\n\n\nindex.qmd\n\n---\ntitle: \"Creating Github-hosted Dashboards\"\nformat:\n    html:\n        embed-resources: true\n        keep-ipynb: false\nauthor: \n    - name: Nick Minor\n      orcid: 0000-0003-2929-8229\n      email: nrminor@wisc.edu\n      affiliation:\n        - University of Wisconsin - Madison\n        - Wisconsin National Primate Research Center\neditor: source\njupyter: python3\n---\n\nWe don’t actually need most of this–the key parts are telling it that we want to use the jupyter engine with Python, that we don’t need to keep the intermediate Jupyter representation after rendering, and that we don’t want our HTML to depend on external files. Instead, we want everything embedded into the HTML, which results in a larger HTML but also a simpler, more foolproof project structure.\nLike with _quarto.yml, there are dozens of controls you can use here; if you need something, check the docs for how to get it. Chances are, there’s a setting for it."
  },
  {
    "objectID": "setup.html#setting-up-quarto",
    "href": "setup.html#setting-up-quarto",
    "title": "Setting up this project",
    "section": "",
    "text": "First, we make sure Quarto is installed, and then use it to create a project in the current working directory with quarto create project. This command is interactive and will guide you through creating the kind of project you want. In this case, the key point is that we want a website project to be created in the current working directory.\nThis will create a few files for use: the _quarto.yml file for whole-project configuration, the index.qmd file that will serve as the homepage and entrypoint for the website, and an about.qmd that will serve as an “About” page in a separate “tab” on the website. We also get a styles.css file, which allows us to do some aesthetic tweaks to what would otherwise be raw, boring HTML. The said, we don’t have to touch it in this case, as the Quarto renderer comes with a number of CSS themes built-in.\n\n\n\n\n\n\nHTML?\n\n\n\n\n\nThe power of Quarto is that it allows you to write simple Markdown and then render it into very long list of other formats, e.g., PowerPoint, PDF, etc. Because we’re using it to make a website, Quarto will be rendering our markdown into HTML, which can then be viewed in the browser.\n\n\n\nBefore we proceed, let’s tweak our Quarto configuration a bit. We’ll do these tweaks at two levels: the whole-project level in _quarto.yml, and in what’s referred to as the frontmatter in each .qmd file.\n\n\nFirst, open the _quarto.yml in your favorite editor (VSCode, Positron, and RStudio have the best support for Quarto, though you can use any editor you can set to recognize .qmd files as Markdown). Start by modifying the top block with an additional setting: output-dir: docs.\n\n\n_quarto.yml\n\nproject:\n  type: website\n  output-dir: docs\n\nNote that the YAML language is very sensitive about indentation, similar to Python. Make sure your editor has good auto-indentation support when modifying these files.\nNext, we’ll modify the website block, which controls navigation and other website behaviors. In this case, I’m going to add a page by putting this qmd file in the list:\n\n\n_quarto.yml\n\nwebsite:\n  title: \"Creating Github-hosted Dashboards\"\n  navbar:\n    left:\n      - href: index.qmd\n        text: Home\n      - about.qmd\n      - setup.qmd\n\nWe won’t touch the format section, but just note that that’s where we specify the theme we want applied to our HTML. These adjustments could be switching to a different built-in theme, or making out own tweaks manually in styles.css.\nFinally, we’re going to add a section at the bottom that tells Quarto not to rerun code unless it has been updated:\n\n\n_quarto.yml\n\nexecute:\n  freeze: auto\n\nAs the look and feel of our project comes together, we can expect to return to the _quarto.yml, but for now, that’s all we’ll need. There are a huge number of controls we can tweak, so I recommend keeping the Quarto docs handy.\n\n\n\nEach .qmd has its own YAML-based configuration, which you’ll see in index.qmd. To demo some of the controls we can use, I modified my index.qmd frontmatter to the following:\n\n\nindex.qmd\n\n---\ntitle: \"Creating Github-hosted Dashboards\"\nformat:\n    html:\n        embed-resources: true\n        keep-ipynb: false\nauthor: \n    - name: Nick Minor\n      orcid: 0000-0003-2929-8229\n      email: nrminor@wisc.edu\n      affiliation:\n        - University of Wisconsin - Madison\n        - Wisconsin National Primate Research Center\neditor: source\njupyter: python3\n---\n\nWe don’t actually need most of this–the key parts are telling it that we want to use the jupyter engine with Python, that we don’t need to keep the intermediate Jupyter representation after rendering, and that we don’t want our HTML to depend on external files. Instead, we want everything embedded into the HTML, which results in a larger HTML but also a simpler, more foolproof project structure.\nLike with _quarto.yml, there are dozens of controls you can use here; if you need something, check the docs for how to get it. Chances are, there’s a setting for it."
  },
  {
    "objectID": "setup.html#setting-up-python",
    "href": "setup.html#setting-up-python",
    "title": "Setting up this project",
    "section": "Setting up python",
    "text": "Setting up python\nThat’s all we need to get Quarto working, but we still need to set up Python so that Quarto can run Python code. To do that, I’m going to use the inimitable uv package manager. The best thing about uv is that it’s fast, really fast.\nThe second best thing is that it can, like Quarto itself, be configured with a single, declarative configuration file called pyproject.toml. This file is in the TOML language instead of YAML, but don’t worry; it should be similarly readable and relatively obvious in what it’s specifying. The uv team has gone to great lengths to make sure this file is compliant with Python-ecosystem standards, which gets rid of headaches you get with some other Python managers like Poetry. uv has tons of killer features and is one of the best things to happen to Python in a long time.\n\n\n\n\n\n\nOn uv\n\n\n\n\n\nCan you tell I love uv?\n\n\n\nTo get started, make sure you have uv installed, and then run uv init --name quarto_dashboards --lib .. This will create a project called quarto-dashboards in the current working directory that is a library rather than an executable. If and when our code gets too big to be viewed in our website, we can put it in our python library and import it in our Quarto python. Cool!\nThis will also generate a Python virtual environment and the aforementioned pyproject.toml for us. Now, let’s put some stuff in it! Our website will need a few things: the Jupyter engine, a Python kernel, and the labkey Python API, all of which are available on the Python Package Index (PyPI) and are thus installable with uv. Just run uv add jupyter ipykernel labkey and then observe the following in pyproject.toml:\n\n\npyproject.toml\n\ndependencies = [\n    \"ipykernel&gt;=6.29.5\",\n    \"jupyter&gt;=1.1.1\",\n    \"labkey&gt;=3.3.0\",\n]\n\n(Note that more dependencies may be added elsewhere in the project, so it’s possible the pyproject.toml file won’t have quite the same dependency listing at the time you read this.)\nAs you can see, we now have our dependencies locked with precise versions, which means our environment will be reproducible.\nTo get into our virtual environment, run source .venv/bin/activate. You will now have access to your dependencies.\n\n\n\n\n\n\nPro-tip on shell aliases\n\n\n\n\n\nOne of the ways uv is standards compliant is by using source .venv/bin/activate, which is used by many other Python environment managers. That said, it’s kind of verbose and ugly, a lot to type.\nBecause I move in and out of Python environments a lot, I’ve placed a few aliases (shorthands) for this in the .zshrc file in my home directory, which is run every time I launch a new terminal window or tab:\n\n\n~/.zshrc\n\nalias uvv='uv sync --all-extras && source .venv/bin/activate'\nalias uvs='uv sync --all-extras'\nalias a='source .venv/bin/activate'\nalias d='deactivate'\n\nIf you use bash and not zsh, placing these aliases in your .bashrc will work too.\nWith that, you’ll be able to run uvv to sync and activate a virtual environment–three keystrokes instead of 50. So power, very efficiency.\n\n\n\n\nPreviewing our project\nWith that, we have what we need to start working on our website. In a new terminal window, tab, or split, activate your virtual environment, and then run quarto preview. If we did everything above correctly, this will open a new browser window or tab with our rendered in-progress website for us. Every time we save changes to our .qmd file, the Quarto preview will see this and re-render our website. Amazing!"
  },
  {
    "objectID": "setup.html#setting-up-git",
    "href": "setup.html#setting-up-git",
    "title": "Setting up this project",
    "section": "Setting up Git",
    "text": "Setting up Git\nYou may be tempted to get writing, but first, do your future self a favor and get your version control organized. The key to this will be your .gitignore. .gitignore files tell git (you guessed it) what to ignore. This is helpful, but these files can quickly become a Sisyphean task; the bigger your project gets, the more you have to add line after line after line of new things you have to ignore. This makes it easy to accidentally commit files you didn’t mean to.\nInstead, we’re going to invert the logic of our .gitignore file: we’re going to use it to say ignore everything by default, and then only add a line for each exception to that rule. This means we’ll only ever be able to stage and commit files and directories that we’ve explicitly allowed in our .gitignore. Inverting your logic means more work up front, of course, but your future self will thank you.\nThis method results in a .gitignore that looks like this at the time of this writing:\n\n\n.gitignore\n\n*\n\n# project root exceptions\n!.gitignore\n!justfile\n!_quarto.yml\n!about.qmd\n!index.qmd\n!setup.qmd\n!styles.css\n!pyproject.toml\n!uv.lock\n!README.md\n!LICENSE\n!.python-version\n\n# python library code\n!/src\n!/src/quarto_dashboards\n!/src/**/*.py\n\n# github workflows\n!/.github\n!/.github/workflows\n!/.github/workflows/*.yml\n!/.github/workflows/*.yaml\n\nYou’ll see ignoring everything is as simple as starting the file with *, the glob wildcard for anything. Then, for each directory and file we want to allow, we prepend the path with a bang !, which is the not operator.\nWe only allow Quarto project files, uv project files, python scripts from our library, and GitHub workflows we’ll eventually write. With this setup, we’ll never accidentally push Jupyter notebooks, JavaScript files Quarto generates, etc.\nNow, just run git init in your terminal and have at it."
  },
  {
    "objectID": "setup.html#setting-up-github-actions",
    "href": "setup.html#setting-up-github-actions",
    "title": "Setting up this project",
    "section": "Setting up GitHub Actions",
    "text": "Setting up GitHub Actions\nRather than rendering our website itself, we’re going to use GitHub to do that for us. To do so, we’re going to return to YAML and put together some workflows. The overall architecture here will be:\n\nLeave our current project setup in a main git branch.\nUse a new branch called gh-pages to actually render the website files.\nUse GitHub pages to host the files output into the docs directory in our gh-pages branch.\nMake sure GitHub re-renders our website whenever changes are pushed to the main branch.\n\nConveniently, the Quarto developers anticipated this use case and wrote a very helpful tutorial for it, which I’ll partially reproduce here.\nThe first thing we need to do is set up a “remote”, which is to say a repository on GiHub that we can sync with this project. To do so, I went to the dholab GitHub org, hit the green new button, and made a repo called “2025-github-website-demo”. I then staged all the files allowed in .gitignore, committed them, and then ran the following to set that repo as our remote\ngit branch -M main\ngit remote add origin https://github.com/dholab/2025-github-website-demo.git\ngit push -u origin main\nWith that, the rest is extremely simple: run quarto publish gh-pages, which will create the gh-pages branch and plug it into a .github.io site, and then paste the following Github workflow into the main branch:\n\n\n.github/workflows/publish.yml\n\non:\n  workflow_dispatch:\n  push:\n    branches: [main]\n\nname: Quarto Publish\n\njobs:\n  build-deploy:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v4\n\n      - name: Set up Quarto\n        uses: quarto-dev/quarto-actions/setup@v2\n\n      - name: Install uv\n        uses: astral-sh/setup-uv@v5\n\n      - name: \"Set up Python\"\n        uses: actions/setup-python@v5\n        with:\n          python-version-file: \".python-version\"\n        \n      - name: Install the project\n        run: uv sync --all-extras --dev\n\n      - name: Render and Publish from local venv\n        run: |\n          source .venv/bin/activate\n          git config --global user.name 'GitHub Actions Bot'\n          git config --global user.email 'actions@github.com'\n          quarto publish gh-pages --no-browser\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n      - name: Define a cache dependency glob\n        uses: astral-sh/setup-uv@v5\n        with:\n          enable-cache: true\n          cache-dependency-glob: \"uv.lock\"\n\nThis workflow, adapted from the above Quarto tutorial plus the uv docs, essentially replicates what we’ve done above, except with the benefit of a previously created uv environment (that’s what uv.lock records)."
  },
  {
    "objectID": "setup.html#parting-words-iterating-on-this-project",
    "href": "setup.html#parting-words-iterating-on-this-project",
    "title": "Setting up this project",
    "section": "Parting words: iterating on this project",
    "text": "Parting words: iterating on this project\nWith everything set up, I recommend the following workflow for iterating on this project:\n\nWhenever you starting making changes, make sure you have quarto preview running within the python environment. That way, you can keep an eye on the rendered project as you update you .qmd and Python code.\nIf you have just installed, run just readme whenever you update setup.qmd. This keeps the repo readme up to date.\nBe sure to use uv add to record any dependencies throughout your Python or .qmd files. Likewise for allowing new files to be git-tracked by adding explicit exceptions to .gitignore.\nFor adding Python, start with putting code into blocks in your .qmd files. When that code starts to get a bit large, e.g. &gt;20 lines, consider placing it in our library and importing it as a function instead.\nKeep in mind that as currently configured, the website-update action will run any time any file in main is updated. If you’re pushing lots of little updates, it may make sense to either a) temporarily disable the publishing action, or b) restrain the action trigger to only when particular files, e.g., particular .qmd or .py files, are updated."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Creating Github-hosted Dashboards",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  }
]